import jsPDF from 'jspdf';
import html2canvas from 'html2canvas';
import * as pdfjsLib from 'pdfjs-dist';

// OneDrive 경로 찾기 함수
const findOneDrivePath = async () => {
  try {
    if (!window.electronAPI || !window.electronAPI.getOneDrivePath) {
      console.error('Electron API를 사용할 수 없습니다. window.electronAPI:', window.electronAPI);
      return null;
    }
    return await window.electronAPI.getOneDrivePath();
  } catch (error) {
    console.error('OneDrive 경로 찾기 실패:', error);
    return null;
  }
};

// Music_Sheets 경로 찾기 함수
const findMusicSheetsPath = async () => {
  try {
    console.log('=== findMusicSheetsPath 시작 ===');
    if (!window.electronAPI || !window.electronAPI.getMusicSheetsPath) {
      console.error('Electron API를 사용할 수 없습니다. window.electronAPI:', window.electronAPI);
      return null;
    }
    const path = await window.electronAPI.getMusicSheetsPath();
    console.log('findMusicSheetsPath 결과:', path);
    return path;
  } catch (error) {
    console.error('Music_Sheets 경로 찾기 실패:', error);
    return null;
  }
};

// 파일 존재 여부 확인 함수
const checkFileExists = async (filePath) => {
  try {
    console.log('파일 존재 여부 확인:', filePath);
    if (!window.electronAPI || !window.electronAPI.readFile) {
      console.error('Electron API를 사용할 수 없습니다.');
      return false;
    }
    
    const fileData = await window.electronAPI.readFile(filePath);
    const exists = fileData !== null && fileData !== undefined;
    console.log('파일 존재 여부:', exists);
    return exists;
  } catch (error) {
    console.log('파일 존재 여부 확인 실패:', error.message);
    return false;
  }
};

// Music_Sheets 디렉토리의 파일 목록 확인 함수
const listMusicSheetsFiles = async () => {
  try {
    console.log('=== Music_Sheets 디렉토리 파일 목록 확인 ===');
    const musicSheetsPath = await findMusicSheetsPath();
    if (!musicSheetsPath) {
      console.error('Music_Sheets 경로를 찾을 수 없습니다.');
      return [];
    }
    
    console.log('Music_Sheets 경로:', musicSheetsPath);
    
    // Electron API를 통해 디렉토리 목록을 가져오는 함수가 있는지 확인
    if (window.electronAPI && window.electronAPI.listFiles) {
      try {
        const files = await window.electronAPI.listFiles(musicSheetsPath);
        console.log('디렉토리 파일 목록:', files);
        return files;
      } catch (error) {
        console.warn('디렉토리 목록 가져오기 실패:', error);
      }
    }
    
    // 디렉토리 목록 API가 없으면 빈 배열 반환
    console.warn('디렉토리 목록 API를 사용할 수 없습니다.');
    return [];
  } catch (error) {
    console.error('파일 목록 확인 실패:', error);
    return [];
  }
};

// 파일 경로를 현재 플랫폼에 맞게 변환하는 함수
const convertFilePathToCurrentPlatform = async (originalFilePath) => {
  try {
    console.log('=== convertFilePathToCurrentPlatform 시작 ===');
    console.log('원본 경로:', originalFilePath);
    
    // Music_Sheets 경로 가져오기
    const musicSheetsPath = await findMusicSheetsPath();
    if (!musicSheetsPath) {
      console.error('Music_Sheets 경로를 찾을 수 없습니다.');
      return null;
    }
    
    console.log('Music_Sheets 경로:', musicSheetsPath);

    // 원본 파일 경로에서 파일명만 추출
    const fileName = originalFilePath.split('/').pop() || originalFilePath.split('\\').pop();
    if (!fileName) {
      console.error('파일명을 추출할 수 없습니다:', originalFilePath);
      return null;
    }
    
    console.log('추출된 파일명:', fileName);
    console.log('파일명 바이트 길이:', new TextEncoder().encode(fileName).length);
    console.log('파일명 인코딩:', encodeURIComponent(fileName));

    // 현재 플랫폼의 Music_Sheets 경로와 파일명을 결합
    // 맥OS에서는 '/' 사용, Windows에서는 '\' 사용
    const pathSeparator = musicSheetsPath.includes('\\') ? '\\' : '/';
    const currentPlatformPath = `${musicSheetsPath}${musicSheetsPath.endsWith(pathSeparator) ? '' : pathSeparator}${fileName}`;
    
    console.log('경로 변환 완료:', originalFilePath, '->', currentPlatformPath);
    return currentPlatformPath;
  } catch (error) {
    console.error('파일 경로 변환 실패:', error);
    console.error('오류 스택:', error.stack);
    return null;
  }
};

// PDF 저장 경로 생성
const getPdfSavePath = async (date) => {
  console.log('=== getPdfSavePath 함수 시작 ===');
  const oneDrivePath = await findOneDrivePath();
  console.log('findOneDrivePath 결과:', oneDrivePath);
  if (!oneDrivePath) {
    throw new Error('OneDrive 경로를 찾을 수 없습니다.');
  }

  // YYYY-MM-DD 형식의 문자열을 직접 파싱하여 시간대 문제 방지
  const [year, month, day] = date.split('-');
  const dateObj = new Date(parseInt(year), parseInt(month) - 1, parseInt(day));
  const dayOfWeek = dateObj.getDay(); // 0=일요일, 5=금요일

  // 요일별 파일명 설정
  const serviceType = dayOfWeek === 5 ? '금요기도회' : '주일예배';
  const fileName = `${year}${month}${day} ${serviceType} 찬양 리스트.pdf`;

  // OneDrive 경로 구성 (수동으로 경로 구분자 처리)
  const pathSeparator = oneDrivePath.includes('\\') ? '\\' : '/';
  const pdfPath = `${oneDrivePath}${pathSeparator}Documents${pathSeparator}Archive${pathSeparator}한소망교회${pathSeparator}찬양 리스트${pathSeparator}찬양리스트모음${pathSeparator}${fileName}`;
  
  console.log('PDF 저장 경로:', pdfPath);
  return pdfPath;
};

// Electron을 통해 이미지 파일을 읽어서 Blob으로 변환
const imageFileToBlob = async (filePath) => {
  try {
    console.log('=== imageFileToBlob 시작 ===');
    console.log('원본 filePath:', filePath);
    
    // Electron API 사용 가능 여부 확인
    if (!window.electronAPI || !window.electronAPI.readFile) {
      console.error('Electron API를 사용할 수 없습니다. window.electronAPI:', window.electronAPI);
      throw new Error('Electron API를 사용할 수 없습니다.');
    }

    // filePath가 이미 전체 경로인지 확인
    let finalFilePath = filePath;
    
    // macOS 경로가 포함되어 있으면 Windows 경로로 변환
    if (filePath.includes('/Users/') || filePath.includes('OneDrive-Personal')) {
      console.log('macOS 경로 감지, 변환 시도...');
      const convertedFilePath = await convertFilePathToCurrentPlatform(filePath);
      if (convertedFilePath) {
        finalFilePath = convertedFilePath;
        console.log('경로 변환 완료:', finalFilePath);
      } else {
        console.warn('경로 변환 실패, 원본 경로 사용:', filePath);
      }
    }

    console.log('최종 파일 경로:', finalFilePath);

    // 파일 존재 여부 확인을 위해 먼저 읽기 시도
    try {
      console.log('파일 읽기 시도 중...');
      const fileData = await window.electronAPI.readFile(finalFilePath);
      
      if (!fileData) {
        console.error('파일 데이터가 null입니다:', finalFilePath);
        throw new Error('파일을 읽을 수 없습니다.');
      }

      console.log('파일 데이터 로드 성공!');
      console.log('파일 데이터 타입:', typeof fileData);
      console.log('파일 데이터 크기:', fileData.length);
      console.log('파일 데이터 처음 100바이트:', fileData.slice(0, 100));

      // 파일 확장자에 따라 MIME 타입 결정
      const extension = finalFilePath.toLowerCase().split('.').pop();
      let mimeType = 'image/jpeg'; // 기본값
      
      switch (extension) {
        case 'jpg':
        case 'jpeg':
          mimeType = 'image/jpeg';
          break;
        case 'png':
          mimeType = 'image/png';
          break;
        case 'pdf':
          // PDF 파일은 이미지로 변환하여 처리
          console.log('PDF 파일 감지, 이미지로 변환 시도:', finalFilePath);
          try {
            const convertedBlob = await convertPDFToImage(fileData);
            if (convertedBlob) {
              console.log('PDF 변환 성공, 크기:', convertedBlob.size);
              return convertedBlob;
            } else {
              console.warn('PDF 변환 실패:', finalFilePath);
              return null;
            }
          } catch (conversionError) {
            console.error('PDF 변환 중 오류:', conversionError);
            return null;
          }
        default:
          console.warn('알 수 없는 파일 확장자:', extension, 'JPEG로 처리');
      }
      
      console.log('MIME 타입:', mimeType);

      // Buffer를 Blob으로 변환
      const blob = new Blob([fileData], { type: mimeType });
      console.log('Blob 생성 성공!');
      console.log('Blob 크기:', blob.size);
      console.log('Blob 타입:', blob.type);
      
      return blob;
    } catch (readError) {
      console.error('파일 읽기 오류:', readError);
      console.error('오류 메시지:', readError.message);
      console.error('오류 스택:', readError.stack);
      
      // 파일이 존재하지 않거나 접근할 수 없는 경우
      if (readError.message.includes('ENOENT') || readError.message.includes('파일을 읽을 수 없습니다')) {
        console.warn('파일이 존재하지 않거나 접근할 수 없습니다:', finalFilePath);
        return null;
      }
      throw readError;
    }
  } catch (error) {
    console.error('이미지 로드 실패:', error);
    console.error('오류 스택:', error.stack);
    return null;
  }
};

// Blob을 Base64로 변환
const blobToBase64 = (blob) => {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = () => resolve(reader.result);
    reader.onerror = reject;
    reader.readAsDataURL(blob);
  });
};

// PDF를 이미지로 변환하는 함수
const convertPDFToImage = async (pdfData) => {
  try {
    console.log('PDF를 이미지로 변환 시작...');
    
    // PDF.js를 사용하여 PDF 로드
    const pdf = await pdfjsLib.getDocument({ data: pdfData }).promise;
    console.log('PDF 로드 완료, 총 페이지 수:', pdf.numPages);
    
    // 첫 번째 페이지만 변환 (악보는 보통 첫 페이지만 필요)
    const page = await pdf.getPage(1);
    const viewport = page.getViewport({ scale: 2.0 }); // 고해상도로 변환
    
    console.log('PDF 페이지 뷰포트:', viewport.width, 'x', viewport.height);
    
    // Canvas 생성
    const canvas = document.createElement('canvas');
    const context = canvas.getContext('2d');
    canvas.height = viewport.height;
    canvas.width = viewport.width;
    
    // PDF 페이지를 Canvas에 렌더링
    const renderContext = {
      canvasContext: context,
      viewport: viewport
    };
    
    console.log('PDF 페이지 렌더링 시작...');
    await page.render(renderContext).promise;
    console.log('PDF 페이지 렌더링 완료');
    
    // Canvas를 Blob으로 변환
    return new Promise((resolve) => {
      canvas.toBlob((blob) => {
        if (blob) {
          console.log('PDF 변환 성공, Blob 크기:', blob.size);
          resolve(blob);
        } else {
          console.error('PDF 변환 실패: Canvas to Blob 변환 실패');
          resolve(null);
        }
      }, 'image/jpeg', 0.95);
    });
  } catch (error) {
    console.error('PDF 변환 중 오류:', error);
    return null;
  }
};

// PDF 생성 함수
export const generateWorshipListPDF = async (songs, date) => {
  try {
    console.log('=== PDF 생성 시작 ===');
    console.log('입력된 날짜:', date);
    console.log('찬양 개수:', songs.length);
    console.log('찬양 리스트 상세:', songs.map(song => ({
      title: song.title,
      fileName: song.fileName,
      hasFilePath: !!song.filePath,
      filePath: song.filePath
    })));
    
    const pdf = new jsPDF({
      orientation: 'portrait',
      unit: 'in',
      format: 'letter'
    });

    // 레터 사이즈: 8.5 x 11 인치
    const pageWidth = 8.5;
    const pageHeight = 11;
    
    // Narrow 여백 설정 (0.5인치)
    const margin = 0.5;
    const contentWidth = pageWidth - (margin * 2);
    const contentHeight = pageHeight - (margin * 2);

    let currentY = margin;
    let isFirstPage = true;
    let successCount = 0;
    let failCount = 0;
    const failedSongs = [];

    // Music_Sheets 디렉토리 파일 목록 확인
    const musicSheetsFiles = await listMusicSheetsFiles();
    console.log('Music_Sheets 디렉토리 파일 목록:', musicSheetsFiles);

    for (let i = 0; i < songs.length; i++) {
      const song = songs[i];
      
      console.log(`\n=== 처리 중인 곡 ${i + 1}/${songs.length} ===`);
      console.log('곡 정보:', {
        title: song.title,
        fileName: song.fileName,
        filePath: song.filePath,
        hasFileName: !!song.fileName,
        hasFilePath: !!song.filePath
      });
      
      // 새 페이지가 필요한지 확인
      if (currentY > pageHeight - margin - 1) {
        pdf.addPage();
        currentY = margin;
        isFirstPage = false;
      }

      // 악보 파일이 있는 경우에만 처리
      if (song.fileName) {
        // filePath가 비어있으면 fileName을 기반으로 경로 구성
        let filePath = song.filePath;
        if (!filePath || filePath === '') {
          const musicSheetsPath = await findMusicSheetsPath();
          if (musicSheetsPath) {
            filePath = `${musicSheetsPath}/${song.fileName}`;
            console.log(`filePath가 비어있어서 구성된 경로: ${filePath}`);
          } else {
            console.warn(`Music_Sheets 경로를 찾을 수 없어서 건너뛰기: ${song.fileName}`);
            failCount++;
            failedSongs.push({
              title: song.title,
              fileName: song.fileName,
              error: 'Music_Sheets 경로를 찾을 수 없습니다.'
            });
            continue;
          }
        }
        
        // 파일 존재 여부 확인
        console.log('파일 존재 여부 확인 중...');
        const fileExists = await checkFileExists(filePath);
        if (!fileExists) {
          console.warn(`파일이 존재하지 않습니다: ${filePath}`);
          
          // Music_Sheets 디렉토리에서 비슷한 파일명 찾기
          const fileNameWithoutExt = song.fileName.toLowerCase().split('.')[0];
          console.log('찾고 있는 파일명 (확장자 제외):', fileNameWithoutExt);
          
          const similarFiles = musicSheetsFiles.filter(file => {
            const fileWithoutExt = file.toLowerCase().split('.')[0];
            const isSimilar = fileWithoutExt.includes(fileNameWithoutExt) || 
                            fileNameWithoutExt.includes(fileWithoutExt) ||
                            file.toLowerCase().includes(fileNameWithoutExt);
            console.log(`파일 비교: "${file}" vs "${song.fileName}" -> ${isSimilar}`);
            return isSimilar;
          });
          
          if (similarFiles.length > 0) {
            console.log('비슷한 파일명 발견:', similarFiles);
            // 첫 번째 비슷한 파일로 시도
            const musicSheetsPath = await findMusicSheetsPath();
            if (musicSheetsPath) {
              const newFilePath = `${musicSheetsPath}/${similarFiles[0]}`;
              console.log(`비슷한 파일로 재시도: ${newFilePath}`);
              filePath = newFilePath;
            }
          } else {
            console.warn('비슷한 파일명도 찾을 수 없습니다.');
            failCount++;
            failedSongs.push({
              title: song.title,
              fileName: song.fileName,
              error: `파일을 찾을 수 없습니다: ${filePath}`
            });
            continue;
          }
        } else {
          console.log('파일 존재 확인됨:', filePath);
        }
      } else {
        console.warn(`악보 파일명이 없습니다: ${song.title}`);
        failCount++;
        failedSongs.push({
          title: song.title,
          fileName: song.fileName || '없음',
          error: '악보 파일명이 없습니다.'
        });
        continue;
      }
      
      try {
          console.log(`이미지 파일 처리 시작: ${filePath}`);
          
          // Electron을 통해 이미지 파일을 Blob으로 로드 (재시도 로직 포함)
          let blob = null;
          let retryCount = 0;
          const maxRetries = 2;
          
          while (!blob && retryCount <= maxRetries) {
            if (retryCount > 0) {
              console.log(`재시도 ${retryCount}/${maxRetries}: ${song.fileName}`);
              // 재시도 전 잠시 대기
              await new Promise(resolve => setTimeout(resolve, 500));
            }
            
            blob = await imageFileToBlob(filePath);
            retryCount++;
          }
          
          if (!blob) {
            console.warn(`이미지 로드 실패 (${maxRetries + 1}회 시도), 건너뛰기: ${song.fileName}`);
            failCount++;
            failedSongs.push({
              title: song.title,
              fileName: song.fileName,
              error: '이미지 파일을 로드할 수 없습니다.'
            });
            continue;
          }

          console.log(`Blob 로드 성공, 크기: ${blob.size} bytes`);

          // Blob을 Base64로 변환
          console.log('Base64 변환 시작...');
          const base64 = await blobToBase64(blob);
          console.log('Base64 변환 완료, 길이:', base64.length);
          
          // 이미지 로드
          console.log('이미지 객체 생성 및 로드 시작...');
          const img = new Image();
          await new Promise((resolve, reject) => {
            img.onload = () => {
              console.log('이미지 로드 성공!');
              console.log('이미지 크기:', img.width, 'x', img.height);
              resolve();
            };
            img.onerror = (error) => {
              console.error('이미지 로드 실패:', error);
              reject(error);
            };
            img.src = base64;
          });

          // 이미지 비율 유지하면서 최대 크기 계산
          const imgAspectRatio = img.width / img.height;
          const contentAspectRatio = contentWidth / contentHeight;
          
          console.log('이미지 비율:', imgAspectRatio);
          console.log('콘텐츠 비율:', contentAspectRatio);
          
          let imgWidth, imgHeight;
          if (imgAspectRatio > contentAspectRatio) {
            // 이미지가 더 넓음 - 너비를 기준으로 조정
            imgWidth = contentWidth;
            imgHeight = contentWidth / imgAspectRatio;
          } else {
            // 이미지가 더 높음 - 높이를 기준으로 조정
            imgHeight = contentHeight;
            imgWidth = contentHeight * imgAspectRatio;
          }

          console.log('계산된 이미지 크기:', imgWidth, 'x', imgHeight);

          // 이미지를 페이지 중간 위쪽에 배치
          const x = margin + (contentWidth - imgWidth) / 2;
          const y = currentY + (contentHeight - imgHeight) / 2 - 0.5; // 위쪽으로 0.5인치 이동
          
          console.log('이미지 배치 위치:', x, y);

          // 이미지를 PDF에 추가
          console.log('PDF에 이미지 추가 중...');
          console.log('addImage 파라미터:', {
            base64: base64.substring(0, 50) + '...',
            format: 'JPEG',
            x: x,
            y: y,
            width: imgWidth,
            height: imgHeight
          });
          
          pdf.addImage(base64, 'JPEG', x, y, imgWidth, imgHeight);
          console.log('PDF에 이미지 추가 완료!');
          successCount++;

          // 다음 이미지를 위해 Y 위치 업데이트
          currentY += imgHeight + 0.2; // 이미지 높이 + 여백
          console.log('다음 이미지 Y 위치:', currentY);

        } catch (error) {
          console.error(`이미지 처리 실패 (${song.fileName}):`, error);
          failCount++;
          failedSongs.push({
            title: song.title,
            fileName: song.fileName,
            error: error.message
          });
          continue;
        }
      }
    }

    // PDF 상태 확인
    console.log('=== PDF 생성 완료 ===');
    console.log('총 페이지 수:', pdf.internal.getNumberOfPages());
    console.log('현재 페이지:', pdf.internal.getCurrentPageInfo().pageNumber);
    console.log('성공한 곡 수:', successCount);
    console.log('실패한 곡 수:', failCount);
    
    if (failedSongs.length > 0) {
      console.log('실패한 곡들:');
      failedSongs.forEach((song, index) => {
        console.log(`${index + 1}. ${song.title} (${song.fileName}): ${song.error}`);
      });
    }
    
    // PDF에 이미지가 있는지 확인
    if (successCount === 0) {
      // 이미지가 하나도 없는 경우
      console.warn('PDF에 이미지가 없습니다. 악보 파일을 확인해주세요.');
      
      // 빈 PDF에 최소한의 텍스트라도 추가
      pdf.setFontSize(16);
      pdf.text('찬양 리스트', 4.25, 5.5, { align: 'center' });
      pdf.setFontSize(12);
      pdf.text(`날짜: ${date}`, 4.25, 6, { align: 'center' });
      pdf.text('악보 파일을 찾을 수 없습니다.', 4.25, 6.5, { align: 'center' });
    }

    // PDF 저장
    console.log('=== PDF 저장 시작 ===');
    const pdfPath = await getPdfSavePath(date);
    console.log('최종 PDF 저장 경로:', pdfPath);
    
    console.log('PDF ArrayBuffer 생성 중...');
    const pdfArrayBuffer = pdf.output('arraybuffer');
    console.log('PDF ArrayBuffer 크기:', pdfArrayBuffer.byteLength);
    
    // ArrayBuffer를 Uint8Array로 변환
    const pdfUint8Array = new Uint8Array(pdfArrayBuffer);
    console.log('PDF Uint8Array 크기:', pdfUint8Array.length);
    
    // Electron을 통해 파일 저장
    if (!window.electronAPI || !window.electronAPI.savePdf) {
      throw new Error('Electron API를 사용할 수 없습니다.');
    }

    console.log('Electron을 통해 PDF 저장 중...');
    const result = await window.electronAPI.savePdf({
      pdfData: pdfUint8Array,
      filePath: pdfPath
    });
    
    console.log('PDF 저장 결과:', result);
    
    if (result.success) {
      let message = `PDF가 성공적으로 생성되었습니다!\n저장 위치: ${pdfPath}\n\n`;
      message += `📊 처리 결과:\n`;
      message += `• 성공: ${successCount}곡\n`;
      message += `• 실패: ${failCount}곡\n`;
      message += `• 총 곡 수: ${songs.length}곡`;
      
      if (failedSongs.length > 0) {
        message += `\n\n❌ 실패한 곡들:\n`;
        failedSongs.forEach((song, index) => {
          message += `${index + 1}. ${song.title} (${song.fileName})\n`;
        });
      }
      
      return {
        success: true,
        message: message,
        filePath: pdfPath,
        stats: {
          total: songs.length,
          success: successCount,
          failed: failCount,
          failedSongs: failedSongs
        }
      };
    } else {
      throw new Error(result.error);
    }

  } catch (error) {
    console.error('PDF 생성 실패:', error);
    return {
      success: false,
      error: error.message
    };
  }
};

// 찬양 리스트 요약 정보 생성
export const generateWorshipListSummary = (songs, date) => {
  const dateObj = new Date(date);
  const dayOfWeek = dateObj.getDay();
  const serviceType = dayOfWeek === 5 ? '금요기도회' : '주일예배';
  
  const totalSongs = songs.length;
  const songsWithMusicSheets = songs.filter(song => song.fileName && song.filePath).length;
  const songsWithoutMusicSheets = totalSongs - songsWithMusicSheets;

  return {
    date: date,
    serviceType: serviceType,
    totalSongs: totalSongs,
    songsWithMusicSheets: songsWithMusicSheets,
    songsWithoutMusicSheets: songsWithoutMusicSheets,
    songs: songs.map(song => ({
      title: song.title,
      key: song.key,
      tempo: song.tempo,
      hasMusicSheet: !!(song.fileName && song.filePath)
    }))
  };
};
