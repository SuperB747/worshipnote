import jsPDF from 'jspdf';
import html2canvas from 'html2canvas';
import * as pdfjsLib from 'pdfjs-dist';

// OneDrive ê²½ë¡œ ì°¾ê¸° í•¨ìˆ˜
const findOneDrivePath = async () => {
  try {
    if (!window.electronAPI || !window.electronAPI.getOneDrivePath) {
      console.error('Electron APIë¥¼ ì‚¬ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. window.electronAPI:', window.electronAPI);
      return null;
    }
    return await window.electronAPI.getOneDrivePath();
  } catch (error) {
    console.error('OneDrive ê²½ë¡œ ì°¾ê¸° ì‹¤íŒ¨:', error);
    return null;
  }
};

// Music_Sheets ê²½ë¡œ ì°¾ê¸° í•¨ìˆ˜
const findMusicSheetsPath = async () => {
  try {
    console.log('=== findMusicSheetsPath ì‹œì‘ ===');
    if (!window.electronAPI || !window.electronAPI.getMusicSheetsPath) {
      console.error('Electron APIë¥¼ ì‚¬ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. window.electronAPI:', window.electronAPI);
      return null;
    }
    const path = await window.electronAPI.getMusicSheetsPath();
    console.log('findMusicSheetsPath ê²°ê³¼:', path);
    return path;
  } catch (error) {
    console.error('Music_Sheets ê²½ë¡œ ì°¾ê¸° ì‹¤íŒ¨:', error);
    return null;
  }
};

// íŒŒì¼ ì¡´ì¬ ì—¬ë¶€ í™•ì¸ í•¨ìˆ˜
const checkFileExists = async (filePath) => {
  try {
    console.log('íŒŒì¼ ì¡´ì¬ ì—¬ë¶€ í™•ì¸:', filePath);
    if (!window.electronAPI || !window.electronAPI.readFile) {
      console.error('Electron APIë¥¼ ì‚¬ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
      return false;
    }
    
    const fileData = await window.electronAPI.readFile(filePath);
    const exists = fileData !== null && fileData !== undefined;
    console.log('íŒŒì¼ ì¡´ì¬ ì—¬ë¶€:', exists);
    return exists;
  } catch (error) {
    console.log('íŒŒì¼ ì¡´ì¬ ì—¬ë¶€ í™•ì¸ ì‹¤íŒ¨:', error.message);
    return false;
  }
};

// Music_Sheets ë””ë ‰í† ë¦¬ì˜ íŒŒì¼ ëª©ë¡ í™•ì¸ í•¨ìˆ˜
const listMusicSheetsFiles = async () => {
  try {
    console.log('=== Music_Sheets ë””ë ‰í† ë¦¬ íŒŒì¼ ëª©ë¡ í™•ì¸ ===');
    const musicSheetsPath = await findMusicSheetsPath();
    if (!musicSheetsPath) {
      console.error('Music_Sheets ê²½ë¡œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
      return [];
    }
    
    console.log('Music_Sheets ê²½ë¡œ:', musicSheetsPath);
    
    // Electron APIë¥¼ í†µí•´ ë””ë ‰í† ë¦¬ ëª©ë¡ì„ ê°€ì ¸ì˜¤ëŠ” í•¨ìˆ˜ê°€ ìˆëŠ”ì§€ í™•ì¸
    if (window.electronAPI && window.electronAPI.listFiles) {
      try {
        const files = await window.electronAPI.listFiles(musicSheetsPath);
        console.log('ë””ë ‰í† ë¦¬ íŒŒì¼ ëª©ë¡:', files);
        return files;
      } catch (error) {
        console.warn('ë””ë ‰í† ë¦¬ ëª©ë¡ ê°€ì ¸ì˜¤ê¸° ì‹¤íŒ¨:', error);
      }
    }
    
    // ë””ë ‰í† ë¦¬ ëª©ë¡ APIê°€ ì—†ìœ¼ë©´ ë¹ˆ ë°°ì—´ ë°˜í™˜
    console.warn('ë””ë ‰í† ë¦¬ ëª©ë¡ APIë¥¼ ì‚¬ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
    return [];
  } catch (error) {
    console.error('íŒŒì¼ ëª©ë¡ í™•ì¸ ì‹¤íŒ¨:', error);
    return [];
  }
};

// íŒŒì¼ ê²½ë¡œë¥¼ í˜„ì¬ í”Œë«í¼ì— ë§ê²Œ ë³€í™˜í•˜ëŠ” í•¨ìˆ˜
const convertFilePathToCurrentPlatform = async (originalFilePath) => {
  try {
    console.log('=== convertFilePathToCurrentPlatform ì‹œì‘ ===');
    console.log('ì›ë³¸ ê²½ë¡œ:', originalFilePath);
    
    // Music_Sheets ê²½ë¡œ ê°€ì ¸ì˜¤ê¸°
    const musicSheetsPath = await findMusicSheetsPath();
    if (!musicSheetsPath) {
      console.error('Music_Sheets ê²½ë¡œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
      return null;
    }
    
    console.log('Music_Sheets ê²½ë¡œ:', musicSheetsPath);

    // ì›ë³¸ íŒŒì¼ ê²½ë¡œì—ì„œ íŒŒì¼ëª…ë§Œ ì¶”ì¶œ
    const fileName = originalFilePath.split('/').pop() || originalFilePath.split('\\').pop();
    if (!fileName) {
      console.error('íŒŒì¼ëª…ì„ ì¶”ì¶œí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤:', originalFilePath);
      return null;
    }
    
    console.log('ì¶”ì¶œëœ íŒŒì¼ëª…:', fileName);
    console.log('íŒŒì¼ëª… ë°”ì´íŠ¸ ê¸¸ì´:', new TextEncoder().encode(fileName).length);
    console.log('íŒŒì¼ëª… ì¸ì½”ë”©:', encodeURIComponent(fileName));

    // í˜„ì¬ í”Œë«í¼ì˜ Music_Sheets ê²½ë¡œì™€ íŒŒì¼ëª…ì„ ê²°í•©
    // ë§¥OSì—ì„œëŠ” '/' ì‚¬ìš©, Windowsì—ì„œëŠ” '\' ì‚¬ìš©
    const pathSeparator = musicSheetsPath.includes('\\') ? '\\' : '/';
    const currentPlatformPath = `${musicSheetsPath}${musicSheetsPath.endsWith(pathSeparator) ? '' : pathSeparator}${fileName}`;
    
    console.log('ê²½ë¡œ ë³€í™˜ ì™„ë£Œ:', originalFilePath, '->', currentPlatformPath);
    return currentPlatformPath;
  } catch (error) {
    console.error('íŒŒì¼ ê²½ë¡œ ë³€í™˜ ì‹¤íŒ¨:', error);
    console.error('ì˜¤ë¥˜ ìŠ¤íƒ:', error.stack);
    return null;
  }
};

// PDF ì €ì¥ ê²½ë¡œ ìƒì„±
const getPdfSavePath = async (date) => {
  console.log('=== getPdfSavePath í•¨ìˆ˜ ì‹œì‘ ===');
  const oneDrivePath = await findOneDrivePath();
  console.log('findOneDrivePath ê²°ê³¼:', oneDrivePath);
  if (!oneDrivePath) {
    throw new Error('OneDrive ê²½ë¡œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
  }

  // YYYY-MM-DD í˜•ì‹ì˜ ë¬¸ìì—´ì„ ì§ì ‘ íŒŒì‹±í•˜ì—¬ ì‹œê°„ëŒ€ ë¬¸ì œ ë°©ì§€
  const [year, month, day] = date.split('-');
  const dateObj = new Date(parseInt(year), parseInt(month) - 1, parseInt(day));
  const dayOfWeek = dateObj.getDay(); // 0=ì¼ìš”ì¼, 5=ê¸ˆìš”ì¼

  // ìš”ì¼ë³„ íŒŒì¼ëª… ì„¤ì •
  const serviceType = dayOfWeek === 5 ? 'ê¸ˆìš”ê¸°ë„íšŒ' : 'ì£¼ì¼ì˜ˆë°°';
  const fileName = `${year}${month}${day} ${serviceType} ì°¬ì–‘ ë¦¬ìŠ¤íŠ¸.pdf`;

  // OneDrive ê²½ë¡œ êµ¬ì„± (ìˆ˜ë™ìœ¼ë¡œ ê²½ë¡œ êµ¬ë¶„ì ì²˜ë¦¬)
  const pathSeparator = oneDrivePath.includes('\\') ? '\\' : '/';
  const pdfPath = `${oneDrivePath}${pathSeparator}Documents${pathSeparator}Archive${pathSeparator}í•œì†Œë§êµíšŒ${pathSeparator}ì°¬ì–‘ ë¦¬ìŠ¤íŠ¸${pathSeparator}ì°¬ì–‘ë¦¬ìŠ¤íŠ¸ëª¨ìŒ${pathSeparator}${fileName}`;
  
  console.log('PDF ì €ì¥ ê²½ë¡œ:', pdfPath);
  return pdfPath;
};

// Electronì„ í†µí•´ ì´ë¯¸ì§€ íŒŒì¼ì„ ì½ì–´ì„œ Blobìœ¼ë¡œ ë³€í™˜
const imageFileToBlob = async (filePath) => {
  try {
    console.log('=== imageFileToBlob ì‹œì‘ ===');
    console.log('ì›ë³¸ filePath:', filePath);
    
    // Electron API ì‚¬ìš© ê°€ëŠ¥ ì—¬ë¶€ í™•ì¸
    if (!window.electronAPI || !window.electronAPI.readFile) {
      console.error('Electron APIë¥¼ ì‚¬ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. window.electronAPI:', window.electronAPI);
      throw new Error('Electron APIë¥¼ ì‚¬ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
    }

    // filePathê°€ ì´ë¯¸ ì „ì²´ ê²½ë¡œì¸ì§€ í™•ì¸
    let finalFilePath = filePath;
    
    // macOS ê²½ë¡œê°€ í¬í•¨ë˜ì–´ ìˆìœ¼ë©´ Windows ê²½ë¡œë¡œ ë³€í™˜
    if (filePath.includes('/Users/') || filePath.includes('OneDrive-Personal')) {
      console.log('macOS ê²½ë¡œ ê°ì§€, ë³€í™˜ ì‹œë„...');
      const convertedFilePath = await convertFilePathToCurrentPlatform(filePath);
      if (convertedFilePath) {
        finalFilePath = convertedFilePath;
        console.log('ê²½ë¡œ ë³€í™˜ ì™„ë£Œ:', finalFilePath);
      } else {
        console.warn('ê²½ë¡œ ë³€í™˜ ì‹¤íŒ¨, ì›ë³¸ ê²½ë¡œ ì‚¬ìš©:', filePath);
      }
    }

    console.log('ìµœì¢… íŒŒì¼ ê²½ë¡œ:', finalFilePath);

    // íŒŒì¼ ì¡´ì¬ ì—¬ë¶€ í™•ì¸ì„ ìœ„í•´ ë¨¼ì € ì½ê¸° ì‹œë„
    try {
      console.log('íŒŒì¼ ì½ê¸° ì‹œë„ ì¤‘...');
      const fileData = await window.electronAPI.readFile(finalFilePath);
      
      if (!fileData) {
        console.error('íŒŒì¼ ë°ì´í„°ê°€ nullì…ë‹ˆë‹¤:', finalFilePath);
        throw new Error('íŒŒì¼ì„ ì½ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
      }

      console.log('íŒŒì¼ ë°ì´í„° ë¡œë“œ ì„±ê³µ!');
      console.log('íŒŒì¼ ë°ì´í„° íƒ€ì…:', typeof fileData);
      console.log('íŒŒì¼ ë°ì´í„° í¬ê¸°:', fileData.length);
      console.log('íŒŒì¼ ë°ì´í„° ì²˜ìŒ 100ë°”ì´íŠ¸:', fileData.slice(0, 100));

      // íŒŒì¼ í™•ì¥ìì— ë”°ë¼ MIME íƒ€ì… ê²°ì •
      const extension = finalFilePath.toLowerCase().split('.').pop();
      let mimeType = 'image/jpeg'; // ê¸°ë³¸ê°’
      
      switch (extension) {
        case 'jpg':
        case 'jpeg':
          mimeType = 'image/jpeg';
          break;
        case 'png':
          mimeType = 'image/png';
          break;
        case 'pdf':
          // PDF íŒŒì¼ì€ ì´ë¯¸ì§€ë¡œ ë³€í™˜í•˜ì—¬ ì²˜ë¦¬
          console.log('PDF íŒŒì¼ ê°ì§€, ì´ë¯¸ì§€ë¡œ ë³€í™˜ ì‹œë„:', finalFilePath);
          try {
            const convertedBlob = await convertPDFToImage(fileData);
            if (convertedBlob) {
              console.log('PDF ë³€í™˜ ì„±ê³µ, í¬ê¸°:', convertedBlob.size);
              return convertedBlob;
            } else {
              console.warn('PDF ë³€í™˜ ì‹¤íŒ¨:', finalFilePath);
              return null;
            }
          } catch (conversionError) {
            console.error('PDF ë³€í™˜ ì¤‘ ì˜¤ë¥˜:', conversionError);
            return null;
          }
        default:
          console.warn('ì•Œ ìˆ˜ ì—†ëŠ” íŒŒì¼ í™•ì¥ì:', extension, 'JPEGë¡œ ì²˜ë¦¬');
      }
      
      console.log('MIME íƒ€ì…:', mimeType);

      // Bufferë¥¼ Blobìœ¼ë¡œ ë³€í™˜
      const blob = new Blob([fileData], { type: mimeType });
      console.log('Blob ìƒì„± ì„±ê³µ!');
      console.log('Blob í¬ê¸°:', blob.size);
      console.log('Blob íƒ€ì…:', blob.type);
      
      return blob;
    } catch (readError) {
      console.error('íŒŒì¼ ì½ê¸° ì˜¤ë¥˜:', readError);
      console.error('ì˜¤ë¥˜ ë©”ì‹œì§€:', readError.message);
      console.error('ì˜¤ë¥˜ ìŠ¤íƒ:', readError.stack);
      
      // íŒŒì¼ì´ ì¡´ì¬í•˜ì§€ ì•Šê±°ë‚˜ ì ‘ê·¼í•  ìˆ˜ ì—†ëŠ” ê²½ìš°
      if (readError.message.includes('ENOENT') || readError.message.includes('íŒŒì¼ì„ ì½ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤')) {
        console.warn('íŒŒì¼ì´ ì¡´ì¬í•˜ì§€ ì•Šê±°ë‚˜ ì ‘ê·¼í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤:', finalFilePath);
        return null;
      }
      throw readError;
    }
  } catch (error) {
    console.error('ì´ë¯¸ì§€ ë¡œë“œ ì‹¤íŒ¨:', error);
    console.error('ì˜¤ë¥˜ ìŠ¤íƒ:', error.stack);
    return null;
  }
};

// Blobì„ Base64ë¡œ ë³€í™˜
const blobToBase64 = (blob) => {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = () => resolve(reader.result);
    reader.onerror = reject;
    reader.readAsDataURL(blob);
  });
};

// PDFë¥¼ ì´ë¯¸ì§€ë¡œ ë³€í™˜í•˜ëŠ” í•¨ìˆ˜
const convertPDFToImage = async (pdfData) => {
  try {
    console.log('PDFë¥¼ ì´ë¯¸ì§€ë¡œ ë³€í™˜ ì‹œì‘...');
    
    // PDF.jsë¥¼ ì‚¬ìš©í•˜ì—¬ PDF ë¡œë“œ
    const pdf = await pdfjsLib.getDocument({ data: pdfData }).promise;
    console.log('PDF ë¡œë“œ ì™„ë£Œ, ì´ í˜ì´ì§€ ìˆ˜:', pdf.numPages);
    
    // ì²« ë²ˆì§¸ í˜ì´ì§€ë§Œ ë³€í™˜ (ì•…ë³´ëŠ” ë³´í†µ ì²« í˜ì´ì§€ë§Œ í•„ìš”)
    const page = await pdf.getPage(1);
    const viewport = page.getViewport({ scale: 2.0 }); // ê³ í•´ìƒë„ë¡œ ë³€í™˜
    
    console.log('PDF í˜ì´ì§€ ë·°í¬íŠ¸:', viewport.width, 'x', viewport.height);
    
    // Canvas ìƒì„±
    const canvas = document.createElement('canvas');
    const context = canvas.getContext('2d');
    canvas.height = viewport.height;
    canvas.width = viewport.width;
    
    // PDF í˜ì´ì§€ë¥¼ Canvasì— ë Œë”ë§
    const renderContext = {
      canvasContext: context,
      viewport: viewport
    };
    
    console.log('PDF í˜ì´ì§€ ë Œë”ë§ ì‹œì‘...');
    await page.render(renderContext).promise;
    console.log('PDF í˜ì´ì§€ ë Œë”ë§ ì™„ë£Œ');
    
    // Canvasë¥¼ Blobìœ¼ë¡œ ë³€í™˜
    return new Promise((resolve) => {
      canvas.toBlob((blob) => {
        if (blob) {
          console.log('PDF ë³€í™˜ ì„±ê³µ, Blob í¬ê¸°:', blob.size);
          resolve(blob);
        } else {
          console.error('PDF ë³€í™˜ ì‹¤íŒ¨: Canvas to Blob ë³€í™˜ ì‹¤íŒ¨');
          resolve(null);
        }
      }, 'image/jpeg', 0.95);
    });
  } catch (error) {
    console.error('PDF ë³€í™˜ ì¤‘ ì˜¤ë¥˜:', error);
    return null;
  }
};

// PDF ìƒì„± í•¨ìˆ˜
export const generateWorshipListPDF = async (songs, date) => {
  try {
    console.log('=== PDF ìƒì„± ì‹œì‘ ===');
    console.log('ì…ë ¥ëœ ë‚ ì§œ:', date);
    console.log('ì°¬ì–‘ ê°œìˆ˜:', songs.length);
    console.log('ì°¬ì–‘ ë¦¬ìŠ¤íŠ¸ ìƒì„¸:', songs.map(song => ({
      title: song.title,
      fileName: song.fileName,
      hasFilePath: !!song.filePath,
      filePath: song.filePath
    })));
    
    const pdf = new jsPDF({
      orientation: 'portrait',
      unit: 'in',
      format: 'letter'
    });

    // ë ˆí„° ì‚¬ì´ì¦ˆ: 8.5 x 11 ì¸ì¹˜
    const pageWidth = 8.5;
    const pageHeight = 11;
    
    // Narrow ì—¬ë°± ì„¤ì • (0.5ì¸ì¹˜)
    const margin = 0.5;
    const contentWidth = pageWidth - (margin * 2);
    const contentHeight = pageHeight - (margin * 2);

    let currentY = margin;
    let isFirstPage = true;
    let successCount = 0;
    let failCount = 0;
    const failedSongs = [];

    // Music_Sheets ë””ë ‰í† ë¦¬ íŒŒì¼ ëª©ë¡ í™•ì¸
    const musicSheetsFiles = await listMusicSheetsFiles();
    console.log('Music_Sheets ë””ë ‰í† ë¦¬ íŒŒì¼ ëª©ë¡:', musicSheetsFiles);

    for (let i = 0; i < songs.length; i++) {
      const song = songs[i];
      
      console.log(`\n=== ì²˜ë¦¬ ì¤‘ì¸ ê³¡ ${i + 1}/${songs.length} ===`);
      console.log('ê³¡ ì •ë³´:', {
        title: song.title,
        fileName: song.fileName,
        filePath: song.filePath,
        hasFileName: !!song.fileName,
        hasFilePath: !!song.filePath
      });
      
      // ìƒˆ í˜ì´ì§€ê°€ í•„ìš”í•œì§€ í™•ì¸
      if (currentY > pageHeight - margin - 1) {
        pdf.addPage();
        currentY = margin;
        isFirstPage = false;
      }

      // ì•…ë³´ íŒŒì¼ì´ ìˆëŠ” ê²½ìš°ì—ë§Œ ì²˜ë¦¬
      if (song.fileName) {
        // filePathê°€ ë¹„ì–´ìˆìœ¼ë©´ fileNameì„ ê¸°ë°˜ìœ¼ë¡œ ê²½ë¡œ êµ¬ì„±
        let filePath = song.filePath;
        if (!filePath || filePath === '') {
          const musicSheetsPath = await findMusicSheetsPath();
          if (musicSheetsPath) {
            filePath = `${musicSheetsPath}/${song.fileName}`;
            console.log(`filePathê°€ ë¹„ì–´ìˆì–´ì„œ êµ¬ì„±ëœ ê²½ë¡œ: ${filePath}`);
          } else {
            console.warn(`Music_Sheets ê²½ë¡œë¥¼ ì°¾ì„ ìˆ˜ ì—†ì–´ì„œ ê±´ë„ˆë›°ê¸°: ${song.fileName}`);
            failCount++;
            failedSongs.push({
              title: song.title,
              fileName: song.fileName,
              error: 'Music_Sheets ê²½ë¡œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.'
            });
            continue;
          }
        }
        
        // íŒŒì¼ ì¡´ì¬ ì—¬ë¶€ í™•ì¸
        console.log('íŒŒì¼ ì¡´ì¬ ì—¬ë¶€ í™•ì¸ ì¤‘...');
        const fileExists = await checkFileExists(filePath);
        if (!fileExists) {
          console.warn(`íŒŒì¼ì´ ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤: ${filePath}`);
          
          // Music_Sheets ë””ë ‰í† ë¦¬ì—ì„œ ë¹„ìŠ·í•œ íŒŒì¼ëª… ì°¾ê¸°
          const fileNameWithoutExt = song.fileName.toLowerCase().split('.')[0];
          console.log('ì°¾ê³  ìˆëŠ” íŒŒì¼ëª… (í™•ì¥ì ì œì™¸):', fileNameWithoutExt);
          
          const similarFiles = musicSheetsFiles.filter(file => {
            const fileWithoutExt = file.toLowerCase().split('.')[0];
            const isSimilar = fileWithoutExt.includes(fileNameWithoutExt) || 
                            fileNameWithoutExt.includes(fileWithoutExt) ||
                            file.toLowerCase().includes(fileNameWithoutExt);
            console.log(`íŒŒì¼ ë¹„êµ: "${file}" vs "${song.fileName}" -> ${isSimilar}`);
            return isSimilar;
          });
          
          if (similarFiles.length > 0) {
            console.log('ë¹„ìŠ·í•œ íŒŒì¼ëª… ë°œê²¬:', similarFiles);
            // ì²« ë²ˆì§¸ ë¹„ìŠ·í•œ íŒŒì¼ë¡œ ì‹œë„
            const musicSheetsPath = await findMusicSheetsPath();
            if (musicSheetsPath) {
              const newFilePath = `${musicSheetsPath}/${similarFiles[0]}`;
              console.log(`ë¹„ìŠ·í•œ íŒŒì¼ë¡œ ì¬ì‹œë„: ${newFilePath}`);
              filePath = newFilePath;
            }
          } else {
            console.warn('ë¹„ìŠ·í•œ íŒŒì¼ëª…ë„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
            failCount++;
            failedSongs.push({
              title: song.title,
              fileName: song.fileName,
              error: `íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: ${filePath}`
            });
            continue;
          }
        } else {
          console.log('íŒŒì¼ ì¡´ì¬ í™•ì¸ë¨:', filePath);
        }
      } else {
        console.warn(`ì•…ë³´ íŒŒì¼ëª…ì´ ì—†ìŠµë‹ˆë‹¤: ${song.title}`);
        failCount++;
        failedSongs.push({
          title: song.title,
          fileName: song.fileName || 'ì—†ìŒ',
          error: 'ì•…ë³´ íŒŒì¼ëª…ì´ ì—†ìŠµë‹ˆë‹¤.'
        });
        continue;
      }
      
      try {
          console.log(`ì´ë¯¸ì§€ íŒŒì¼ ì²˜ë¦¬ ì‹œì‘: ${filePath}`);
          
          // Electronì„ í†µí•´ ì´ë¯¸ì§€ íŒŒì¼ì„ Blobìœ¼ë¡œ ë¡œë“œ (ì¬ì‹œë„ ë¡œì§ í¬í•¨)
          let blob = null;
          let retryCount = 0;
          const maxRetries = 2;
          
          while (!blob && retryCount <= maxRetries) {
            if (retryCount > 0) {
              console.log(`ì¬ì‹œë„ ${retryCount}/${maxRetries}: ${song.fileName}`);
              // ì¬ì‹œë„ ì „ ì ì‹œ ëŒ€ê¸°
              await new Promise(resolve => setTimeout(resolve, 500));
            }
            
            blob = await imageFileToBlob(filePath);
            retryCount++;
          }
          
          if (!blob) {
            console.warn(`ì´ë¯¸ì§€ ë¡œë“œ ì‹¤íŒ¨ (${maxRetries + 1}íšŒ ì‹œë„), ê±´ë„ˆë›°ê¸°: ${song.fileName}`);
            failCount++;
            failedSongs.push({
              title: song.title,
              fileName: song.fileName,
              error: 'ì´ë¯¸ì§€ íŒŒì¼ì„ ë¡œë“œí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.'
            });
            continue;
          }

          console.log(`Blob ë¡œë“œ ì„±ê³µ, í¬ê¸°: ${blob.size} bytes`);

          // Blobì„ Base64ë¡œ ë³€í™˜
          console.log('Base64 ë³€í™˜ ì‹œì‘...');
          const base64 = await blobToBase64(blob);
          console.log('Base64 ë³€í™˜ ì™„ë£Œ, ê¸¸ì´:', base64.length);
          
          // ì´ë¯¸ì§€ ë¡œë“œ
          console.log('ì´ë¯¸ì§€ ê°ì²´ ìƒì„± ë° ë¡œë“œ ì‹œì‘...');
          const img = new Image();
          await new Promise((resolve, reject) => {
            img.onload = () => {
              console.log('ì´ë¯¸ì§€ ë¡œë“œ ì„±ê³µ!');
              console.log('ì´ë¯¸ì§€ í¬ê¸°:', img.width, 'x', img.height);
              resolve();
            };
            img.onerror = (error) => {
              console.error('ì´ë¯¸ì§€ ë¡œë“œ ì‹¤íŒ¨:', error);
              reject(error);
            };
            img.src = base64;
          });

          // ì´ë¯¸ì§€ ë¹„ìœ¨ ìœ ì§€í•˜ë©´ì„œ ìµœëŒ€ í¬ê¸° ê³„ì‚°
          const imgAspectRatio = img.width / img.height;
          const contentAspectRatio = contentWidth / contentHeight;
          
          console.log('ì´ë¯¸ì§€ ë¹„ìœ¨:', imgAspectRatio);
          console.log('ì½˜í…ì¸  ë¹„ìœ¨:', contentAspectRatio);
          
          let imgWidth, imgHeight;
          if (imgAspectRatio > contentAspectRatio) {
            // ì´ë¯¸ì§€ê°€ ë” ë„“ìŒ - ë„ˆë¹„ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ì¡°ì •
            imgWidth = contentWidth;
            imgHeight = contentWidth / imgAspectRatio;
          } else {
            // ì´ë¯¸ì§€ê°€ ë” ë†’ìŒ - ë†’ì´ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ì¡°ì •
            imgHeight = contentHeight;
            imgWidth = contentHeight * imgAspectRatio;
          }

          console.log('ê³„ì‚°ëœ ì´ë¯¸ì§€ í¬ê¸°:', imgWidth, 'x', imgHeight);

          // ì´ë¯¸ì§€ë¥¼ í˜ì´ì§€ ì¤‘ê°„ ìœ„ìª½ì— ë°°ì¹˜
          const x = margin + (contentWidth - imgWidth) / 2;
          const y = currentY + (contentHeight - imgHeight) / 2 - 0.5; // ìœ„ìª½ìœ¼ë¡œ 0.5ì¸ì¹˜ ì´ë™
          
          console.log('ì´ë¯¸ì§€ ë°°ì¹˜ ìœ„ì¹˜:', x, y);

          // ì´ë¯¸ì§€ë¥¼ PDFì— ì¶”ê°€
          console.log('PDFì— ì´ë¯¸ì§€ ì¶”ê°€ ì¤‘...');
          console.log('addImage íŒŒë¼ë¯¸í„°:', {
            base64: base64.substring(0, 50) + '...',
            format: 'JPEG',
            x: x,
            y: y,
            width: imgWidth,
            height: imgHeight
          });
          
          pdf.addImage(base64, 'JPEG', x, y, imgWidth, imgHeight);
          console.log('PDFì— ì´ë¯¸ì§€ ì¶”ê°€ ì™„ë£Œ!');
          successCount++;

          // ë‹¤ìŒ ì´ë¯¸ì§€ë¥¼ ìœ„í•´ Y ìœ„ì¹˜ ì—…ë°ì´íŠ¸
          currentY += imgHeight + 0.2; // ì´ë¯¸ì§€ ë†’ì´ + ì—¬ë°±
          console.log('ë‹¤ìŒ ì´ë¯¸ì§€ Y ìœ„ì¹˜:', currentY);

        } catch (error) {
          console.error(`ì´ë¯¸ì§€ ì²˜ë¦¬ ì‹¤íŒ¨ (${song.fileName}):`, error);
          failCount++;
          failedSongs.push({
            title: song.title,
            fileName: song.fileName,
            error: error.message
          });
          continue;
        }
      }
    }

    // PDF ìƒíƒœ í™•ì¸
    console.log('=== PDF ìƒì„± ì™„ë£Œ ===');
    console.log('ì´ í˜ì´ì§€ ìˆ˜:', pdf.internal.getNumberOfPages());
    console.log('í˜„ì¬ í˜ì´ì§€:', pdf.internal.getCurrentPageInfo().pageNumber);
    console.log('ì„±ê³µí•œ ê³¡ ìˆ˜:', successCount);
    console.log('ì‹¤íŒ¨í•œ ê³¡ ìˆ˜:', failCount);
    
    if (failedSongs.length > 0) {
      console.log('ì‹¤íŒ¨í•œ ê³¡ë“¤:');
      failedSongs.forEach((song, index) => {
        console.log(`${index + 1}. ${song.title} (${song.fileName}): ${song.error}`);
      });
    }
    
    // PDFì— ì´ë¯¸ì§€ê°€ ìˆëŠ”ì§€ í™•ì¸
    if (successCount === 0) {
      // ì´ë¯¸ì§€ê°€ í•˜ë‚˜ë„ ì—†ëŠ” ê²½ìš°
      console.warn('PDFì— ì´ë¯¸ì§€ê°€ ì—†ìŠµë‹ˆë‹¤. ì•…ë³´ íŒŒì¼ì„ í™•ì¸í•´ì£¼ì„¸ìš”.');
      
      // ë¹ˆ PDFì— ìµœì†Œí•œì˜ í…ìŠ¤íŠ¸ë¼ë„ ì¶”ê°€
      pdf.setFontSize(16);
      pdf.text('ì°¬ì–‘ ë¦¬ìŠ¤íŠ¸', 4.25, 5.5, { align: 'center' });
      pdf.setFontSize(12);
      pdf.text(`ë‚ ì§œ: ${date}`, 4.25, 6, { align: 'center' });
      pdf.text('ì•…ë³´ íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.', 4.25, 6.5, { align: 'center' });
    }

    // PDF ì €ì¥
    console.log('=== PDF ì €ì¥ ì‹œì‘ ===');
    const pdfPath = await getPdfSavePath(date);
    console.log('ìµœì¢… PDF ì €ì¥ ê²½ë¡œ:', pdfPath);
    
    console.log('PDF ArrayBuffer ìƒì„± ì¤‘...');
    const pdfArrayBuffer = pdf.output('arraybuffer');
    console.log('PDF ArrayBuffer í¬ê¸°:', pdfArrayBuffer.byteLength);
    
    // ArrayBufferë¥¼ Uint8Arrayë¡œ ë³€í™˜
    const pdfUint8Array = new Uint8Array(pdfArrayBuffer);
    console.log('PDF Uint8Array í¬ê¸°:', pdfUint8Array.length);
    
    // Electronì„ í†µí•´ íŒŒì¼ ì €ì¥
    if (!window.electronAPI || !window.electronAPI.savePdf) {
      throw new Error('Electron APIë¥¼ ì‚¬ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
    }

    console.log('Electronì„ í†µí•´ PDF ì €ì¥ ì¤‘...');
    const result = await window.electronAPI.savePdf({
      pdfData: pdfUint8Array,
      filePath: pdfPath
    });
    
    console.log('PDF ì €ì¥ ê²°ê³¼:', result);
    
    if (result.success) {
      let message = `PDFê°€ ì„±ê³µì ìœ¼ë¡œ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤!\nì €ì¥ ìœ„ì¹˜: ${pdfPath}\n\n`;
      message += `ğŸ“Š ì²˜ë¦¬ ê²°ê³¼:\n`;
      message += `â€¢ ì„±ê³µ: ${successCount}ê³¡\n`;
      message += `â€¢ ì‹¤íŒ¨: ${failCount}ê³¡\n`;
      message += `â€¢ ì´ ê³¡ ìˆ˜: ${songs.length}ê³¡`;
      
      if (failedSongs.length > 0) {
        message += `\n\nâŒ ì‹¤íŒ¨í•œ ê³¡ë“¤:\n`;
        failedSongs.forEach((song, index) => {
          message += `${index + 1}. ${song.title} (${song.fileName})\n`;
        });
      }
      
      return {
        success: true,
        message: message,
        filePath: pdfPath,
        stats: {
          total: songs.length,
          success: successCount,
          failed: failCount,
          failedSongs: failedSongs
        }
      };
    } else {
      throw new Error(result.error);
    }

  } catch (error) {
    console.error('PDF ìƒì„± ì‹¤íŒ¨:', error);
    return {
      success: false,
      error: error.message
    };
  }
};

// ì°¬ì–‘ ë¦¬ìŠ¤íŠ¸ ìš”ì•½ ì •ë³´ ìƒì„±
export const generateWorshipListSummary = (songs, date) => {
  const dateObj = new Date(date);
  const dayOfWeek = dateObj.getDay();
  const serviceType = dayOfWeek === 5 ? 'ê¸ˆìš”ê¸°ë„íšŒ' : 'ì£¼ì¼ì˜ˆë°°';
  
  const totalSongs = songs.length;
  const songsWithMusicSheets = songs.filter(song => song.fileName && song.filePath).length;
  const songsWithoutMusicSheets = totalSongs - songsWithMusicSheets;

  return {
    date: date,
    serviceType: serviceType,
    totalSongs: totalSongs,
    songsWithMusicSheets: songsWithMusicSheets,
    songsWithoutMusicSheets: songsWithoutMusicSheets,
    songs: songs.map(song => ({
      title: song.title,
      key: song.key,
      tempo: song.tempo,
      hasMusicSheet: !!(song.fileName && song.filePath)
    }))
  };
};
